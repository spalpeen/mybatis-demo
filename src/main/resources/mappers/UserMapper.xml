<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!-- mapper:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 ，为了使用接口动态代理，这里必须是接口的全路径名-->
<mapper namespace="com.kongming.mybatis.demo.dao.UserMapper">
    <!--    二级缓存-->
    <!--    <cache-->
    <!--        eviction="FIFO"-->
    <!--        flushInterval="60000"-->
    <!--        size="512"-->
    <!--        readOnly="true"-->
    <!--    当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化 方式来保存对象-->
    <!--    />-->
    <!--
        ***重点***
       1.#{},预编译的方式preparedstatement，使用占位符替换，防止sql注入，一个参数的时候，任意参数名可以接收
       2.${},普通的Statement，字符串直接拼接，不可以防止sql注入，一个参数的时候，必须使用${value}接收参数
     -->

    <select id="queryUserByTableName" resultType="com.kongming.mybatis.demo.domain.pojo.User">
        select * from ${tableName}
    </select>

    <select id="login" resultType="com.kongming.mybatis.demo.domain.pojo.User">
        select * from tb_user where user_name = #{userName} and password = #{password}
    </select>

    <!-- statement，内容：sql语句。
       id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
       resultType：sql语句查询结果集的封装类型，使用动态代理之后和方法的返回类型一致；resultMap：二选一
       parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
     -->
    <select id="queryUserById" resultType="com.kongming.mybatis.demo.domain.pojo.User">
        select * from tb_user where id = #{id}
    </select>
    <select id="queryUserAll" resultType="com.kongming.mybatis.demo.domain.pojo.User">
        select * from tb_user
    </select>
    <!-- 新增的Statement
       id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
       parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
       useGeneratedKeys:开启主键回写
       keyColumn：指定数据库的主键
       keyProperty：主键对应的pojo属性名
     -->
    <insert id="insertUser" useGeneratedKeys="true" keyColumn="id" keyProperty="id"
            parameterType="com.kongming.mybatis.demo.domain.pojo.User">
        INSERT INTO tb_user (
        id,
        user_name,
        password,
        name,
        age,
        sex,
        birthday,
        created,
        updated
        )
        VALUES
        (
        null,
        #{userName},
        #{password},
        #{name},
        #{age},
        #{sex},
        #{birthday},
        NOW(),
        NOW()
        );
    </insert>

<!--    <sql id="commonSql">-->
<!--        id,-->
<!--        user_name,-->
<!--        password,-->
<!--        name,-->
<!--        age,-->
<!--        sex,-->
<!--        birthday,-->
<!--        created,-->
<!--        updated-->
<!--    </sql>-->
<!--        <select id="queryUserAll" resultType="com.kongming.mybatis.demo.domain.pojo.User">-->
<!--            select <include refid="commonSql"/>  from tb_user-->
<!--        </select>-->
    <!--
       更新的statement
       id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
       parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
     -->
        <update id="updateUser" parameterType="com.kongming.mybatis.demo.domain.pojo.User">
            UPDATE tb_user
            <trim prefix="set" suffixOverrides=",">
                <if test="userName!=null">user_name = #{userName},</if>
                <if test="password!=null">password = #{password},</if>
                <if test="name!=null">name = #{name},</if>
                <if test="age!=null">age = #{age},</if>
                <if test="sex!=null">sex = #{sex},</if>
                <if test="birthday!=null">birthday = #{birthday},</if>
                updated = now(),
            </trim>
            WHERE
            (id = #{id});
        </update>
    <!--
       删除的statement
       id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
       parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
     -->
        <delete id="deleteUserById" parameterType="java.lang.String">
            delete from tb_user where id=#{id}
        </delete>

    <!--    动态查询-->
    <!--    <select id="queryUserList" resultType="com.kongming.mybatis.demo.domain.pojo.User">-->
    <!--        select <include refid="commonSql"/>  from tb_user where sex = 1-->
    <!--        <if test="name!=null and name.trim() !=''">-->
    <!--            and name like '%${name}%'-->
    <!--        </if>-->
    <!--    </select>-->

        <select id="queryUserListByNameOrAge" resultType="com.kongming.mybatis.demo.domain.pojo.User">
            select * from tb_user where sex = 1
    <!--
    1.一旦有条件成立的when，后续的when则不会执行
    2.当所有的when都不执行时,才会执行otherwise
    -->
            <choose>
                <when test="name!=null and name.trim()!=''">
                    and name like '%${name}%'
                </when>
                <when test="age!=null">
                    and name like '#{age}'
                </when>
                <otherwise>
                    and name='鹏程'
                </otherwise>
            </choose>
        </select>

        <select id="queryUserListByNameAndAge" resultType="com.kongming.mybatis.demo.domain.pojo.User">
            select * from tb_user
    <!--如果多出一个and，会自动去除，如果缺少and或者多出多个and则会报错-->
            <where>
                <if test="name!=null and name.trim()!=''">
                    and name like '%${name}%'
                </if>
                <if test="age!=null">
                    and age = #{age}
                </if>
            </where>
        </select>

        <select id="queryUserListByIds" resultType="com.kongming.mybatis.demo.domain.pojo.User">
            select * from tb_user where id in
            <foreach collection="ids" item="id" open="(" close=")" separator=",">
                #{id}
            </foreach>
        </select>

        <select id="queryUserListByTime" resultType="com.kongming.mybatis.demo.domain.pojo.User">
            select * from tb_user where sex = 1 and (status <![CDATA[ >= ]]> 1  and  status <![CDATA[ <= ]]> 2)
            <![CDATA[
                and mm.ttime > to_date(#{startDateTime},'yyyy-mm-dd hh24:mi:ss')
                and mm.ttime <= to_date(#{endDateTime},'yyyy-mm-dd hh24:mi:ss')
            ]]>
        </select>
    <!--    使用<![CDATA[ ]]>标记的sql语句中的<where> <if>等标签不会被解析-->

    <!--    <sql id="defUser">-->
    <!--SELECT u.*,a.ID as aid,A.MONEY-->
    <!--FROM USER u LEFT JOIN ACCOUNT a-->
    <!--ON a.UID = u.id-->
    <!--    </sql>-->

    <!--    <resultMap id="userAccountMap" type="user">-->
    <!--    <id property="id" column="id"></id>-->
    <!--    <result property="username" column="username"/>-->
    <!--    <result property="birthday" column="birthday"/>-->
    <!--    <result property="sex" column="sex"/>-->
    <!--    <result property="address" column="address"/>-->
    <!--    &lt;!&ndash;账户定义集合&ndash;&gt;-->
    <!--    &lt;!&ndash;property 集合属性名&ndash;&gt;-->
    <!--    &lt;!&ndash;ofType 集合的泛型&ndash;&gt;-->
    <!--    <collection property="accounts" ofType="com.yuan.doman.Account">-->
    <!--        <id column="aid" property="id"/>-->
    <!--        <result column="uid" property="uid"/>-->
    <!--        <result column="money" property="money"/>-->
    <!--    </collection>-->
    <!--    </resultMap>-->
</mapper>